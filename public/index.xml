<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Это неправильные пчелы</title>
    <link>http://www.romange.com/</link>
    <description>Recent content on Это неправильные пчелы</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Dec 2018 11:59:52 +0300</lastBuildDate>
    
	<atom:link href="http://www.romange.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction to fibers in c&#43;&#43;</title>
      <link>http://www.romange.com/2018/12/15/introduction-to-fibers-in-c--/</link>
      <pubDate>Sat, 15 Dec 2018 11:59:52 +0300</pubDate>
      
      <guid>http://www.romange.com/2018/12/15/introduction-to-fibers-in-c--/</guid>
      <description>In my post about Seastar we&amp;rsquo;ve covered continuations style asynchronous programming. My personal opinion is that this style is hard to work with in C++. In this post I would like to cover alternative, Fiber-based approach. In this post I will use Boost.Fibers library in all my examples.
Fibers, or green threads, or cooperative threads are similar to regular threads but with few important distinctions:
 Fibers can not switch between system threads and they are usually pinned to a specific thread.</description>
    </item>
    
    <item>
      <title>Seastar - Asynchronous C&#43;&#43; framework</title>
      <link>http://www.romange.com/2018/07/12/seastar---asynchronous-c---framework/</link>
      <pubDate>Thu, 12 Jul 2018 20:45:24 +0300</pubDate>
      
      <guid>http://www.romange.com/2018/07/12/seastar---asynchronous-c---framework/</guid>
      <description>&lt;p&gt;Lately there are many discussions in programming community in general and in c++ community in particular on how to write efficient asynchronous code. Many concepts like futures, continuations, coroutines are being discussed by c++ standard comittee but not much progress was made besides very minimal support of C++11 futures.&lt;/p&gt;

&lt;p&gt;On the other hand, many mainstream programming languages progressed quicker and adopted asynchronous models either into a core language or popularized it via standard libraries. For example, coroutines are used in Python (yield) and Lua.
Continuations and futures are used extensively in Java. Golang and Erlang are using green threads.
Callback based actor models are used in C and Javascript. Due to lack of official support for asynchronous programming in C++ the community introduced ad-hoc frameworks and libraries that allow writing asynchronous code in C++.&lt;/p&gt;

&lt;p&gt;I would like to share my opinion on what I think will be the best direction for asynchronous models in C++ by reviewing two prominents frameworks: &lt;a href=&#34;http://seastar.io/&#34;&gt;Seastar&lt;/a&gt; and &lt;a href=&#34;https://boost.org/doc/libs/1_67_0/libs/fiber/doc/html/index.html&#34;&gt;Boost.Fiber&lt;/a&gt;. This (opiniated) post reviews Seastar.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing cheap and precise clock</title>
      <link>http://www.romange.com/2017/11/02/implementing-cheap-and-precise-clock/</link>
      <pubDate>Thu, 02 Nov 2017 13:37:51 +0200</pubDate>
      
      <guid>http://www.romange.com/2017/11/02/implementing-cheap-and-precise-clock/</guid>
      <description>&lt;p&gt;The posix API for querying high-precision hardware clocks is &lt;code&gt;clock_gettime&lt;/code&gt;. If one second precision is fine then &lt;code&gt;time(nullptr)&lt;/code&gt; is your friend. Unfortunately, using precice clocks takes its price - they are more expensive CPU-wise.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Reloading data structures under high throughput</title>
      <link>http://www.romange.com/2017/09/29/reloading-data-structures-under-high-throughput/</link>
      <pubDate>Fri, 29 Sep 2017 15:46:55 +0300</pubDate>
      
      <guid>http://www.romange.com/2017/09/29/reloading-data-structures-under-high-throughput/</guid>
      <description>&lt;p&gt;Suppose you have a multi-threaded server that serves tens of thousands read queries per second. Those queries use a shared data-structure or index that is mostly immutable during the server run with the exception of periodic index reloads.  How do you implement data reloads in that server while keeping it live and kicking in production?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>How to serialize integers into memory</title>
      <link>http://www.romange.com/2017/09/26/how-to-serialize-integers-into-memory/</link>
      <pubDate>Tue, 26 Sep 2017 22:46:30 +0300</pubDate>
      
      <guid>http://www.romange.com/2017/09/26/how-to-serialize-integers-into-memory/</guid>
      <description>&lt;p&gt;Here is the analysis of a recent bug I&amp;rsquo;ve stumbled upon. My initial reaction was that
the problem is in the compiler (or that &lt;a href=&#34;https://www.youtube.com/watch?v=PIuE5J9dfAo&#34;&gt;&amp;ldquo;These are wrong bees&amp;rdquo;&lt;/a&gt;). Consider the code below. We copy 64 integers into a properly allocated destination buffer and yet, if compiled with &lt;code&gt;-O3&lt;/code&gt; switch this code crashes with segfault!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>My first post</title>
      <link>http://www.romange.com/2017/09/26/my-first-post/</link>
      <pubDate>Tue, 26 Sep 2017 16:16:40 +0300</pubDate>
      
      <guid>http://www.romange.com/2017/09/26/my-first-post/</guid>
      <description>&lt;p&gt;Hi it&amp;rsquo;s my first attemp at blogging. I&amp;rsquo;ve chosen &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; with
&lt;a href=&#34;https://github.com/digitalcraftsman/hugo-icarus-theme&#34;&gt;Icarus theme&lt;/a&gt; for the content generation.
This blog is going to be published vi my &lt;a href=&#34;https://github.com/romange/blog&#34;&gt;github repository&lt;/a&gt;.
Stay tuned!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>